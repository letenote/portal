{"ast":null,"code":"import _createClass from \"/Users/rezaaditya/Documents/github/portal/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/rezaaditya/Documents/github/portal/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/Users/rezaaditya/Documents/github/portal/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rezaaditya/Documents/github/portal/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * {@link workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * @memberof workbox-routing\n * @extends workbox-routing.Route\n */\n\nvar RegExpRoute = /*#__PURE__*/function (_Route) {\n  _inherits(RegExpRoute, _Route);\n\n  var _super = _createSuper(RegExpRoute);\n\n  /**\n   * If the regular expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * the captured values will be passed to the\n   * {@link workbox-routing~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  function RegExpRoute(regExp, handler, method) {\n    _classCallCheck(this, RegExpRoute);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern'\n      });\n    }\n\n    var match = function match(_ref) {\n      var url = _ref.url;\n      var result = regExp.exec(url.href); // Return immediately if there's no match.\n\n      if (!result) {\n        return;\n      } // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n\n\n      if (url.origin !== location.origin && result.index !== 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"The regular expression '\".concat(regExp.toString(), \"' only partially matched \") + \"against the cross-origin URL '\".concat(url.toString(), \"'. RegExpRoute's will only \") + \"handle cross-origin requests if they match the entire URL.\");\n        }\n\n        return;\n      } // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n\n\n      return result.slice(1);\n    };\n\n    return _super.call(this, match, handler, method);\n  }\n\n  return _createClass(RegExpRoute);\n}(Route);\n\nexport { RegExpRoute };","map":null,"metadata":{},"sourceType":"module"}